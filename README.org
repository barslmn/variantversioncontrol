#+title: Variant Version Control

Variant version control (VVC) is a tool for tracking changes over time in
variant annotation from source like Ensembl, NCBI, Clingen via their APIs'.
VVC helps you to store the variant that you are interested in a git repository.
Makes it possible to track changes in variant annotation with git commits.
Informs you of the annotation changes by mail or notification.

* Installation

git clone

*Set up a cron job*
~cron~ is a tool for periodic job execution.
To update weekly run the following command.

https://crontab.guru/#0_9_*_*_3

* Usage

* API Table

| name | description | source    | url | path | data | parameters |
|------+-------------+-----------+-----+------+------+------------|
| VEP  |             | Ensembl   |     |      |      |            |
|      |             | Mutalyzer |     |      |      |            |
|      |             | ClinGen   |     |      |      |            |
|      |             | InterVar  |     |      |      |            |
|      |             | LitVar    |     |      |      |            |


| VEP  | Ensembl VEP annotation | ensembl | https://rest.ensembl.org | =/vep/homo_sapiens/region/= | '{"variants":["%VCF"]}' | refseq=1   |
https://wintervar.wglab.org/url.php
https://rest.ensembl.org/documentation/info/variant_recoder



* [ ] Source

Some variables

+ VVC_DIR
+ VVC_REPOSITORY
+ VVC_LOGLVL
  options are: DEBUG, INFO, WARNING, ERROR

#+BEGIN_SRC sh :tangle ./vvc :comments both :shebang "#!/bin/sh"
LC_ALL=C
if [ -z "$VVC_DIR" ]; then
    VVC_DIR="$HOME/.local/share"
fi

if [ -z "$VVC_LOGLVL" ]; then
    VVC_LOGLVL="INFO"
fi

if [ -z "$VVC_REPOSITORY" ]; then
    VVC_REPOSITORY="my_variants"
fi
VARIANT_REPOSITORY="$VVC_DIR/$VVC_REPOSITORY"
CURRENT_DIR="$PWD"
readonly VERSION="0.0.1"
#+END_SRC


Help function

#+BEGIN_SRC sh :tangle ./vvc :comments both
usage() {
    cat <<HELP
Usage
vvc { update | add | remove | show | list | tsvlist | version }
vvc provides a high-level commandline interface for the keeping track of
variant annotation changes from sources like Ensembl, NCBI via their API's.

update
    update is used to resynchronize the variant annotations from their sources.
add
    add is followed by one variant identifier (rs number, SPDI, hgvs) desired to be annotated and keep track of
remove
    remove is identical to add except that variants are removed and no longer kept track of.
search
    search for the given regex(7) term(s) from the list of track variants and display matches.
show
    show information about the given variant including its install source and update mechanism.
history
    show change history of the given variant.
list
    list the variants.
tsvlist
    tsv formatted list the variants
help
    show this help
version
    show vvc version
HELP
}
#+END_SRC

message formatter

#+BEGIN_SRC sh :tangle ./vvc :comments both
fancy_message() (
    if [ -z "${1}" ] || [ -z "${2}" ]; then
        return
    fi

    RED="\e[31m"
    GREEN="\e[32m"
    YELLOW="\e[33m"
    MAGENTA="\e[35m"
    RESET="\e[0m"
    MESSAGE_TYPE=""
    MESSAGE=""
    MESSAGE_TYPE="${1}"
    MESSAGE="${2}"

    case ${MESSAGE_TYPE} in
        info) printf "  [${GREEN}+${RESET}] %s\n" "${MESSAGE}" ;;
        progress) printf "  [${GREEN}+${RESET}] %s" "${MESSAGE}" ;;
        recommend) printf "  [${MAGENTA}!${RESET}] %s\n" "${MESSAGE}" ;;
        warn) printf "  [${YELLOW}*${RESET}] WARNING! %s\n" "${MESSAGE}" ;;
        error) printf "  [${RED}!${RESET}] ERROR! %s\n" "${MESSAGE}" ;;
        fatal)
            printf "  [${RED}!${RESET}] ERROR! %s\n" "${MESSAGE}"
            exit 1
            ;;
        *) printf "  [?] UNKNOWN: %s\n" "${MESSAGE}" ;;
    esac
)
#+END_SRC

log level message

#+BEGIN_SRC sh :tangle ./vvc :comments both
get_log_level() {
    lvl="$1"
    case $lvl in
        debug | DEBUG | d | D)
            lvl="0"
            ;;
        info | INFO | I | i)
            lvl="1"
            ;;
        warning | warn | WARNING | WARN | W | w)
            lvl="2"
            ;;
        error | err | ERROR | ERR | E | e)
            lvl="3"
            ;;
    esac
    echo $lvl
}

LOGLVL=$(get_log_level $VVC_LOGLVL)
if [ "$LOGLVL" = 0 ]; then set -xv; fi

log() {
    level=$1
    message=$2
    loglvl=$(get_log_level "$level")
    if [ "$loglvl" -ge "$LOGLVL" ]; then
        case $loglvl in
            0 | debug)
                fancy_message "info" "$level $message"
                ;;
            1 | info)
                fancy_message "info" "$level $message"
                ;;
            2 | warn)
                fancy_message "warning" "$level $message"
                ;;
            3 | err)
                fancy_message "error" "$level $message"
                ;;
        esac
    fi
}
#+END_SRC

check variant repository

#+BEGIN_SRC sh :tangle ./vvc :comments both
check_variant_repository() {
    if [ -d "$VARIANT_REPOSITORY" ]; then
        log "debug" "Directory $VARIANT_REPOSITORY exists. Changing directory."
        cd "$VARIANT_REPOSITORY" || exit
        if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
            log "debug" "Variant Repository at $VARIANT_REPOSITORY exists."
            return 0
        else
            log "info" "Variant Repository at $VARIANT_REPOSITORY does not exist. Creating it for you."
            git init
            touch "$VARIANT_REPOSITORY/variants"
            git add variants annotations/
            git commit "initial commit"
        fi
    else
        log "info" "Directory $VARIANT_REPOSITORY does not exist. Creating it for you."
        mkdir -p "$VARIANT_REPOSITORY/annotations"
        check_variant_repository
    fi
}
#+END_SRC

#+BEGIN_SRC sh :tangle ./vvc :comments both
validate_variant() {
    VARIANT="$1"
    if echo "$VARIANT" | grep -P '(chr|)([1-9]|1[1-9]|2[0-2]|X|Y):(\d+):(A|T|C|G)+:(A|T|C|G)+' >/dev/null; then
        fancy_message info "$VARIANT variant passed the regex validation."
    else
        fancy_message error "$VARIANT variant needs to be in SPDI format."
    fi
}
#+END_SRC



+ Map to other assembly information https://rest.ensembl.org/documentation/info/assembly_map
#+BEGIN_SRC sh
curl -s 'https://rest.ensembl.org/map/human/GRCh38/18:36156575..36156575:1/GRCh37?' -H 'Content-type:application/json' | jq ".mappings[].mapped"
#+END_SRC

+ Get other variant representations https://rest.ensembl.org/documentation/info/variant_recoder
#+BEGIN_SRC sh :tangle ./vvc :comments both
# $1="18:36156575:G:A"
variant_recoder() (
    myMETHOD="GET"
    myHEADER="Content-type:application/json"
    # myPARAMETERS="?assembly=GCF_000001405.38"
    myDATA="$1"
    myURL="$myPROTOCOL"://"$myHOST"/"$myPATH"/"$myDATA"
    RESPONSE=$(curl -s -X "$myMETHOD" "$myURL" -H "$myHEADER")
    echo "$RESPONSE"
)
#+END_SRC


+ get VEP annotation
#+BEGIN_SRC sh :tangle ./vvc :comments both
get_vep() (
    VARIANT="$1"
    myMETHOD="GET"
    myHEADER="Content-type:application/json"
    # myPARAMETERS="?assembly=GCF_000001405.38"
    myDATA="$1"
    myURL="$myPROTOCOL"://"$myHOST"/"$myPATH"/"$myDATA"
    RESPONSE=$(curl -s -X "$myMETHOD" "$myURL" -H "$myHEADER")
    echo "$RESPONSE"
)
#+END_SRC

+ Get rs id
#+BEGIN_SRC sh :tangle ./vvc :comments both
# $1="NC_000008.11:19956017:A:G"
get_rsid() {
    SPDI="$1"
    myMETHOD="GET"
    myHEADER="Content-Type: text/plain; charset=utf-8"
    myURL="$myPROTOCOL"://"$myHOST"/"$myPATH"
    RESPONSE=$(curl -s -X "$myMETHOD" "$myURL" -H "$myHEADER")
    export RESPONSE
    case "$RESPONSE" in
        *"does not match any RSID"*)
            fancy_message info "No rs id found for the variant: $SPDI"
            echo "NOVEL"
            ;;
        *"error"*)
            fancy_message error "An error occured while getting the rs id for the variant $1"
            fancy_message error "$RESPONSE"
            fancy_message error "Exiting..."
            exit 1
            ;;
    esac
    echo "$RESPONSE"
}
#+END_SRC


#+BEGIN_SRC sh :tangle ./vvc :comments both
# $1=267
get_alfa() {
    rsid="$1"
    myMETHOD="GET"
    myHEADER="accept: application/json"
    myURL="$myPROTOCOL"://"$myHOST"/"$myPATH"
    RESPONSE=$(curl -s -X "$myMETHOD" "$myURL" -H "$myHEADER")
    export RESPONSE
    case "$RESPONSE" in
        *"error"*)
            fancy_message error "An error occured while getting the frequencies for rsid $rsid"
            fancy_message error "$RESPONSE"
            ;;
    esac
    echo "$RESPONSE"
}
#+END_SRC

+ get litvar
#+BEGIN_SRC sh :tangle ./vvc :comments both
# $1=rs267,rs5,rs6
get_litvar() {
    rsid="$1"
    myMETHOD="GET"
    myHEADER="accept: application/json"
    myURL="$myPROTOCOL"://"$myHOST"/"$myPATH"
    RESPONSE=$(curl -s -X "$myMETHOD" "$myURL" -H "$myHEADER")
    export RESPONSE
    case "$RESPONSE" in
        ,*"error"*)
            fancy_message error "An error occured while getting the frequencies for rsid $rsid"
            fancy_message error "$RESPONSE"
            ;;
    esac
    echo "$RESPONSE"
}
#+END_SRC

#+BEGIN_SRC sh :tangle ./vvc :comments both
# $1=hgvsg
get_clingen() {
    hgvsg="$1"
    myURL="$myPROTOCOL"://"$myHOST"/"$myPATH"
    RESPONSE=$(curl -s -X "$myMETHOD" "$myURL" -H "$myHEADER")
    case "$RESPONSE" in
        ,*"error"*)
            fancy_message error "An error occured while getting ClinGen for $hgvsg"
            fancy_message error "$RESPONSE"
            ;;
    esac
    echo "$RESPONSE"
}

# curl the URL return the JSON result
#+END_SRC

+ update variant

| step | using   | description                                     |
|------+---------+-------------------------------------------------|
|    1 | ENSEMBL | First run ensembl recoder.                      |
|    2 | ENSEMBL | Get VEP annotation                              |
|    3 | JQ      | Get HGVSg and refseq SPDI from ensembl/recoder. |
|    4 | NCBI    | Get rsid from ncbi/variation using that HGVSg   |
|    5 | NCBI    | Get frequencies from alfa usind rsid.           |
|    6 | NCBI    | Get pmids from litvar using rsid.               |



+ [ ] spliceai
 curl -k https://spliceailookup-api.broadinstitute.org/spliceai/\?hg\=38\&variant\=chr8-140300616-T-G | jq "."

** Somatic
+ [ ] CIVIC
+ [ ] Onkokb
+ [ ] CancerVar

#+BEGIN_SRC sh :tangle ./vvc :comments both
ENSEMBLHOST="ensembl"
VEPPATH="$ENSEMBLHOST/vep"
VARRECPATH="$ENSEMBLHOST/variantrecoder"
NCBIHOST="ncbi"
ALFAPATH="$NCBIHOST/alfa"
LITVARPATH="$NCBIHOST/litvar"

CLINGENHOST="clingen"
CLINGENPATH="$CLINGENHOST/interpretations"

# $1 path
# $2 data
write_data() {
    mkdir -p "annotations/$1"
    echo "$2" | jq -S '.' >"annotations/$1/data"
}
api_call() {
    URL="$1"
    METHOD="GET"
    HEADER="accept: application/json"
    RESPONSE=$(curl -s -X "$METHOD" "$URL" -H "$HEADER")
    echo "$RESPONSE"
}

API_TABLE="
RECODER_URL https://rest.ensembl.org/variant_recoder/human/$spdi
VEP_URL     https://rest.ensembl.org/vep/human/hgvs/$hgvsg
RSID_URL    https://api.ncbi.nlm.nih.gov/variation/v0/spdi/$spdi/rsids
ALFA_URL    https://api.ncbi.nlm.nih.gov/variation/v0/refsnp/$rsid/frequency
LITVAR_URL  https://ncbi.nlm.nih.gov/research/bionlp/litvar/api/v1/entity/litvar/rs$rsid%23%23
CLINGEN_URL https://erepo.genome.network/evrepo/api/interpretations?hgvs=$hgvsg
"

update_variant() {
    while IFS= read -r line; do
        identifiers=""
        tmp=$(mktemp)
        path=$(echo $line | awk -F"\t" '{print $1}')
        url=$(echo $line | awk -F"\t" '{print $2}')
        handler=$(echo $line | awk -F"\t" '{print $3}')
        echo "$identifiers\nURL=$url" > $tmp
        . $tmp
        response=$(api_call $URL)
        if [ -z "$handler" ]; then
            sh $handler $response
        fi
        write_data $response $path
    done < apitable.tsv | sed '/^$/d'
    git add .
    git commit -m "updated $variant"
}
# update_variant() {
#     varrec=$(variant_recoder "$variant")
#     write_data "$variant/$VARRECPATH" "$varrec"
#     hgvsg=$(echo "$varrec" | jq -r '.[][].hgvsg[] | @text')
#     refseq_spdi=$(echo "$varrec" | jq -r '.[][].spdi[]')
#     vep_data=$(get_vep "$hgvsg")
#     write_data "$variant/$VEPPATH" "$vep_data"
#     rsid=$(get_rsid "$refseq_spdi" | jq -r ".[].rsids[]")
#     alfa_data=$(get_alfa "$rsid")
#     write_data "$variant/$ALFAPATH" "$alfa_data"
#     litvar_data=$(get_litvar "$rsid")
#     write_data "$variant/$LITVARPATH" "$litvar_data"
#     clingen_data=$(get_clingen "$hgvsg")
#     write_data "$variant/$CLINGENPATH" "$clingen_data"
#     git add .
#     git commit -m "updated $variant"
# }
#+END_SRC


#+BEGIN_SRC sh :tangle ./vvc :comments both
update_annotations() {
    log "info" "Updating all variants."
    while IFS= read -r variant; do
        update_variant "$variant"
    done <variants
}
#+END_SRC

add variant

#+BEGIN_SRC sh :tangle ./vvc :comments both
add_variant() {
    variant="$1"
    if grep "$variant" variants >/dev/null; then
        log "info" "variant already added! Exiting."
        exit
    fi
    validate_variant "$variant"

    log "info" "Adding variant $variant"
    echo "$variant" >>variants
    mkdir -p "annotations/$variant/"
    git add variants "annotations/$variant/"
    git commit -m "added variant $variant"
    update_variant "$variant"
}
#+END_SRC


#+BEGIN_SRC sh :tangle ./vvc :comments both
check_variant_repository

if [ -n "${1}" ]; then
    ACTION="$1"
    shift
else
    fancy_message error "You must specify an action."
    # usage
    exit 1
fi

case ${ACTION} in
    add | remove | show)
        if [ -z "${1}" ]; then
            fancy_message error "You must specify a variant:\n"
            list_variants
            exit 1
        fi
        ;;
esac

case "${ACTION}" in
    show) ;;
    add)
        for variant in "$@"; do
            add_variant "$variant"
        done
        ;;
    list)
        list_variants
        ;;
    tsv_list | tsvlist | tsv)
        tsvlist_variants
        ;;
    remove) ;;

    search)
        list_variants | grep "${1}"
        ;;
    update)
        update_annotations
        ;;
    version) echo "${VERSION}" ;;
    help) usage ;;
    *) fancy_message fatal "Unknown action supplied: ${ACTION}" ;;
esac

cd "$CURRENT_DIR" || exit
if [ "$LOGLVL" = 0 ]; then set +xv; fi
#+END_SRC

* Singularity Recipe

#+BEGIN_SRC shell :tangle ./Singularity.recipe
Bootstrap: docker
From: ubuntu:rolling

%post
  apt-get -y update
  apt-get -y install git jq curl

%files
  hello.py /

%runscript
  python /hello.py
#+END_SRC
